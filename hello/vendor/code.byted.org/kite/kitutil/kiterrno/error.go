package kiterrno

import (
	"errors"
	"regexp"
	"strconv"
	"strings"
)

// KiteError is the only error type that used in official codes of kite framework.
// Framework extensions developer should convert implement this interface for their
// own error types for consistency.
type KiteError interface {
	error
	Category() int
	Errno() int
	Underlying() error // Return the underlying error if there is one.
}

const (
	errSep    string = "/"
	errPrefix string = "KE."
)

// kiteErr is the official implementation of KiteError.
type kiteErr struct {
	category   int
	errno      int
	underlying error
	errMsg     string
}

// NewKiteError creates an KiteError instance.
func NewKiteError(category int, errno int, underlying error) KiteError {
	ke := &kiteErr{category, errno, underlying, ""}
	ke.errMsg = ke.buildErrorMessage()
	return ke
}

// ParseErrorMessage parses the given message and try to restore a KiteError instance.
// Return a KiteError instance only when the errMsg is generated by a KiteError instance
// from a registered category without conflicts.
// Otherwise, return nil.
func ParseErrorMessage(errMsg string) KiteError {
	if len(errMsg) == 0 {
		return nil
	}

	if !strings.Contains(errMsg, errPrefix) {
		return nil
	}

	match := format.FindStringSubmatch(errMsg)
	if match == nil {
		return nil
	}
	category, _ := strconv.Atoi(match[2])
	errno, _ := strconv.Atoi(match[4])
	name, desc := QueryErrorCode(category, errno)

	if IsUnregisteredCategory(name) || name != match[1] || desc != match[3] {
		// Valid KiteError but conflicts with registered category
		// Treat it as a simple error
		return nil
	}

	var underlying error
	if len(match[5]) > 0 {
		underlying = errors.New(match[5])
	}
	return NewKiteError(category, errno, underlying)
}

var format = regexp.MustCompile(
	`KE\.([^/]+)/(-?\d+) - ([^/]+)/(-?\d+)(?:: (.*))?$`,
)

// Error implements the method from 'error' interface.
func (ke *kiteErr) Error() string {
	return ke.errMsg
}

// buildErrorMessage creates the full error message for kiteErr
func (ke *kiteErr) buildErrorMessage() string {
	var underlying string
	if ke.underlying != nil {
		underlying = ": " + ke.underlying.Error()
	}
	cgstr, nostr := strconv.Itoa(ke.category), strconv.Itoa(ke.errno)
	name, desc := QueryErrorCode(ke.category, ke.errno)
	return errPrefix + name + errSep + cgstr + " - " + desc + errSep + nostr + underlying
}

// Category implements the method from 'KiteError' interface.
func (ke *kiteErr) Category() int {
	return ke.category
}

// Errno implements the method from 'KiteError' interface.
func (ke *kiteErr) Errno() int {
	return ke.errno
}

// Underlying implements the method from 'KiteError' interface.
func (ke *kiteErr) Underlying() error {
	return ke.underlying
}
