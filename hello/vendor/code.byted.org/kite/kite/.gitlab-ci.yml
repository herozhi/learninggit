# Pipeline only create by Merge Request
# build the project using MR's target branch (master or develop) for kitc/kitutil
# check Version Code update if target branch is master

stages:
  - setup         # 基础构建
  - setup_dev     # develop 补充构建
  - check_version # version 更新检查
  - test          # 单元测试
  - benchmark     # 性能压测
  - pprof         # one to one 服务分析
  - cleanup       # 清理

# check & init env
before_script:
  - date && pwd && whoami && id
  - export PATH="$GOROOT/bin:$GOPATH/bin:$PATH"
  - cd $CI_PROJECT_DIR && export CI_COMMIT_MSG=$(git log -1 --format='%cn | %s')  # commit message
  - env && which go

# build project
setup:
  stage: setup
  only:
    variables:
      - $CI_MERGE_REQUEST
  script:
    - if [ -d $GOPATH ]; then rm -rf $GOPATH; fi
    - mkdir -p $GOPATH
    - mkdir -p $KITEROOT
    - cp -r $DEP_REPO_DIR $GOPATH # 减少三方包拉取时间
    - cp -r $CI_PROJECT_DIR $KITEROOT
    - cd $KITEROOT/$CI_PROJECT_NAME
    - git config --global url."git@code.byted.org:".insteadOf "https://code.byted.org/"
    - go get -v -d ./...

# MR 目标分支 develop, kitc/kitutil 基于 develop 构建
setup_dev:
  stage: setup_dev
  only:
    variables:
      - $CI_MERGE_REQUEST
    variables:
      - $MR_TARGET_REF == "develop"
  script:
    - cd $KITEROOT/kitutil && git checkout -b ${MR_TARGET_REF} origin/${MR_TARGET_REF}
    - cd $KITEROOT/kitc && git checkout -b ${MR_TARGET_REF} origin/${MR_TARGET_REF}
    - cd $KITEROOT/$CI_PROJECT_NAME

# MR 目标分支 master, 进行 version code 检查
check_version:
  stage: check_version
  only:
    variables:
      - $CI_MERGE_REQUEST
    variables:
      - $MR_TARGET_REF == "master"
  script:
    # get version code from kite.go
    - SOURCE_VERSION=`grep 'Version\s*=\s*\"v[0-9]\{1,\}\.[0-9]\{1,\}\.[0-9]\{1,\}\"' *.go | awk -F '\"' '{print $(NF-1)}'`
    - git checkout master
    - MASTER_VERSION=`grep 'Version\s*=\s*\"v[0-9]\{1,\}\.[0-9]\{1,\}\.[0-9]\{1,\}\"' *.go | awk -F '\"' '{print $(NF-1)}'`
    - git checkout $CI_COMMIT_SHA
    # version 检查, 相同则退出
    - IFS="." sarr=($SOURCE_VERSION) marr=($MASTER_VERSION) snum=${sarr[0]}*10000+${sarr[1]}*100+${sarr[2]} mnum=${marr[0]}*10000+${marr[1]}*100+${marr[2]}
    - if [[ $snum -le $mnum ]]; then echo "Version 未更新, $CI_COMMIT_REF_NAME[$SOURCE_VERSION] <= $MR_TARGET_REF[$MASTER_VERSION]" && exit -1; fi

test:
  stage: test
  only:
    variables:
      - $CI_MERGE_REQUEST
  script:
    - cd $KITEROOT/$CI_PROJECT_NAME
    - go get -v github.com/facebookgo/ensure
    - go test -v -cover -bench -race ./...

# MR 目标分支 master 或 develop, 需要执行 benchmark
# hotfix/ 分支跳过本阶段
benchmark:
  stage: benchmark
  only:
    variables:
      - $CI_MERGE_REQUEST
    variables:
      - $MR_TARGET_REF == "develop"
      - $MR_TARGET_REF == "master"
  except:
    variables:
      - $MR_SOURCE_REF =~ /hotfix/
  script:
    - which benchcmp
    - rm -rf $RECORD_REPO && git clone git@code.byted.org:kite/testrecord.git $RECORD_REPO  # get record repo
    - cd $KITEROOT/$CI_PROJECT_NAME
    - BenchmarkCMD="go test -bench=. -benchmem -run=none ./..." # benchmark command
    # 获取 源分支 benchmark 数据 commit.txt
    - SourceTxt="${RECORD_REPO}/benchmark/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}.txt"
    - if [ -f ${SourceTxt} ]; then rm ${SourceTxt}; fi
    - ${BenchmarkCMD} > ${SourceTxt}
    # 获取 目标分支 benchmark 数据 commit.txt
    - git checkout $MR_TARGET_REF
    - TargetCommit=$(git log -1 --pretty=%H)
    - TargetTxt="${RECORD_REPO}/benchmark/${CI_PROJECT_NAME}/${TargetCommit}.txt"
    - if ! [ -f ${TargetTxt} ]; then echo "benchmark $MR_TARGET_REF..." && ${BenchmarkCMD} > ${TargetTxt}; fi
    - git checkout $CI_COMMIT_SHA
    # benchmark 性能对比
    - CmpLog="${RECORD_REPO}/benchcmp/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}.log"
    - CmpLogURL="${RECORD_HTTP_PREFIX}/benchcmp/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}.log"
    - if [ -f ${CmpLog} ]; then rm ${CmpLog}; fi
    - benchcmp ${TargetTxt} ${SourceTxt} > ${CmpLog}
    # 组织 lark 文本内容, 显式转义
    - CONTENT="branch=${CI_COMMIT_REF_NAME}\ntarget=${MR_TARGET_REF}\ncommit=${CI_COMMIT_SHA}\n${CI_COMMIT_MSG}\nBenchmark:${CmpLogURL}\n"
    - "curl ${LARK_WEBHOOK} -X POST -H \"Content-Type: application/json\" -d \"{\\\"title\\\": \\\"${CI_PROJECT_NAME} benchmark\\\", \\\"text\\\": \\\"${CONTENT}\\\"}\""
    # 记录更新 push
    - cd ${RECORD_REPO} && git add . && git commit -m "add ${CI_PROJECT_NAME} benchmark record, commit ${CI_COMMIT_SHA}, ${CI_COMMIT_MSG}" && git push && cd -

# MR 目标分支 master 或 develop, 需要执行 pprof
# hotfix/ 分支跳过本阶段
# pprof 阶段会产生四份文件: pprof.top, pprof.pdf, pprof.svg, pprof.pb.gz
# CI/CD + TCE 可能会增加 git 触发自动上线能力, 如有可以替换 cgroup 方案
pprof:
  stage: pprof
  only:
    variables:
      - $CI_MERGE_REQUEST
    variables:
      - $MR_TARGET_REF == "develop"
      - $MR_TARGET_REF == "master"
  except:
    variables:
      - $MR_SOURCE_REF =~ /hotfix/
  script:
    - cd $KITEROOT/$CI_PROJECT_NAME
    - cd ${RECORD_REPO} && git pull && cd -
    # 文件名前缀 和 链接前缀
    - PprofFilePrefix="${RECORD_REPO}/pprof/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}"
    - PprofURLPrefix="${RECORD_HTTP_PREFIX}/pprof/${CI_PROJECT_NAME}/${CI_COMMIT_SHA}"
    # 删除旧文件
    - if [ -f ${PprofFilePrefix}.top ]; then rm ${PprofFilePrefix}.top; fi
    - if [ -f ${PprofFilePrefix}.pdf ]; then rm ${PprofFilePrefix}.pdf; fi
    - if [ -f ${PprofFilePrefix}.svg ]; then rm ${PprofFilePrefix}.svg; fi
    - if [ -f ${PprofFilePrefix}.pb.gz ]; then rm ${PprofFilePrefix}.pb.gz; fi
    # 更新 performancetest 到 源分支
    - curl 10.224.7.27:3457?branch=${CI_COMMIT_REF_NAME}\&target=${MR_TARGET_REF}
    - sleep 20
    # client 发起调用
    - curl 10.224.5.148:3456/RunTest -d '{"Interval":10,"Count":100000000,"Length":100}'
    - sleep 10
    # pprof search, 获取 pb.gz, top, svg
    - go tool pprof -proto http://10.224.7.27:13456/debug/pprof/profile\?seconds\=60 > ${PprofFilePrefix}.pb.gz
    - go tool pprof -top ${PprofFilePrefix}.pb.gz > ${PprofFilePrefix}.top
    - go tool pprof -pdf ${PprofFilePrefix}.pb.gz > ${PprofFilePrefix}.pdf
    - go tool pprof -svg ${PprofFilePrefix}.pb.gz > ${PprofFilePrefix}.svg
    # client 停止调用
    - curl 10.224.5.148:3456/StopTest -d '{}'
    # 记录更新 push
    - cd ${RECORD_REPO} && git add . && git commit -m "add ${CI_PROJECT_NAME} pprof record, commit ${CI_COMMIT_SHA}, ${CI_COMMIT_MSG}" && git push && cd -
    # 组织 lark 文本内容, 显式转义
    - CONTENT="branch=${CI_COMMIT_REF_NAME}\ntarget=${MR_TARGET_REF}\ncommit=${CI_COMMIT_SHA}\n${CI_COMMIT_MSG}\nTOP:${PprofURLPrefix}.top\nPDF:${PprofURLPrefix}.pdf\nSVG:${PprofURLPrefix}.svg\nSource:${PprofURLPrefix}.pb.gz\n"
    - "curl ${LARK_WEBHOOK} -X POST -H \"Content-Type: application/json\" -d \"{\\\"title\\\": \\\"${CI_PROJECT_NAME} pprof\\\", \\\"text\\\": \\\"${CONTENT}\\\"}\""

cleanup:
  stage: cleanup
  only:
    variables:
      - $CI_MERGE_REQUEST
  script:
    - go clean -modcache
    - echo "GOPATH=${GOPATH}"
    - chmod -R +w $GOPATH
    - rm -rf $GOPATH
  when: always
