package kite

import (
	"context"
	"errors"
	"fmt"
	"net"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"strconv"
	"sync"
	"syscall"
	"time"
	"unsafe"

	opentracing "github.com/opentracing/opentracing-go"

	"code.byted.org/gopkg/env"
	"code.byted.org/gopkg/logs"
	"code.byted.org/gopkg/thrift"
	"code.byted.org/kite/endpoint"
	"code.byted.org/kite/kite/gls"
	"code.byted.org/kite/kitutil/kiterrno"
	trace "code.byted.org/trace/trace-client-go"
)

const (
	infrastructionKey  = "K_INFRASTRUCTION"
	addrFromConnection = "K_ADDR_FROM_CONNECTION"
	glsStorageKey      = "K_GLS_STORAGE"
)

var (
	// RPCServer is singleton RpcServer instance
	RPCServer *RpcServer

	// Processor is thrift Processor, set by code generated by kitool
	Processor thrift.TProcessor

	processorSupportContext bool

	// IDLs this service use
	IDLs = make(map[string]string) // map[filename]content
)

// Init .
func Init() {
	// in tce env, MY_CPU_LIMIT will be set as limit cpu cores.
	if v := os.Getenv("GOMAXPROCS"); v == "" {
		if v := os.Getenv("MY_CPU_LIMIT"); v != "" {
			n, err := strconv.ParseInt(v, 10, 64)
			if err == nil {
				runtime.GOMAXPROCS(int(n))
			}
		}
	}

	// conf priority: file > envs > args
	initFromArgs()
	if ConfigFile == "" {
		fmt.Fprintf(os.Stderr, "configfile is empty, use -conf option or %s environment", _ENV_CONFIG_FILE)
		Usage()
	}
	if LogDir == "" {
		fmt.Fprintf(os.Stderr, "logdir is empty, use -log option or %s environment", _ENV_LOG_DIR)
		Usage()
	}
	initFromEnvs()
	if ServiceName == "" {
		fmt.Fprintf(os.Stderr, "servicename is empty, use -svc option or %s environment", _ENV_SERVICE_NAME)
		Usage()
	}
	initFromConfFile()
	if ServicePort == "" {
		fmt.Fprintln(os.Stderr, "no service port, please checkout your args and conffile")
		os.Exit(-1)
	}

	// init databus config
	initDatabusChannel()

	if !EnableMetrics {
		metricsClient = &EmptyEmiter{}
	}

	// init tracing component
	if EnableTracing {
		if err := trace.Init(ServiceName); err != nil {
			opentracing.SetGlobalTracer(opentracing.NoopTracer{})
		}
	}

	initKiteLogger()

	if ServiceMeshMode {
		fmt.Fprintf(os.Stdout, "KITE: open service mesh ingress mode at %s\n", ServiceMeshIngressAddr)
	}

	// create the singleton server instance
	RPCServer = NewRpcServer()

	_, processorSupportContext = Processor.(thrift.TProcessorWithContext)
}

// Run starts the default RpcServer.
// It blocks until recv SIGTERM, SIGHUP or SIGINT.
func Run() error {
	errCh := make(chan error, 1)
	go func() { errCh <- RPCServer.ListenAndServe() }()
	if err := waitSignal(errCh); err != nil {
		return err
	}
	return RPCServer.Stop()
}

// RunWithListener starts the default RpcServer with the Listener ln.
// It's similar to Run
func RunWithListener(ln net.Listener) error {
	if ServiceMeshMode && ServiceMeshIngressAddr != "" && ServiceMeshIngressAddr != ln.Addr().String() {
		logs.Warnf("KITE: using service mesh: expected listening on %s actual %s", ServiceMeshIngressAddr, ln.Addr())
	}
	errCh := make(chan error, 1)
	go func() { errCh <- RPCServer.Serve(ln) }()
	if err := waitSignal(errCh); err != nil {
		return err
	}
	return RPCServer.Stop()
}

func waitSignal(errCh chan error) error {
	signals := make(chan os.Signal, 1)
	signal.Notify(signals, syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM)

	// flush opentracing spans in queue when server exit
	defer trace.Close()

	// service may not be available as soon as startup,  delay registeration to consul.
	// It doesn't work in TCE env.
	delayRegister := time.After(10 * time.Second)

	for {
		select {
		case sig := <-signals:
			switch sig {
			case syscall.SIGTERM:
				return errors.New(sig.String()) // force exit
			case syscall.SIGHUP, syscall.SIGINT:
				return nil // graceful shutdown
			}
		case err := <-errCh:
			return err
		case <-delayRegister:

			// Auto register to consul.
			// It doesn't work in TCE env.
			if err := Register(); err != nil {
				logs.Errorf("KITE: Register service error: %s", err)
			}
			defer StopRegister()
		}
	}
}

func InitMethodContext(ctx context.Context, method string) context.Context {
	// 此时还未进行协议解析, 缺少上游等信息, 无法进行如拉取动态配置等更多的操作;
	// 因此这里只做最少且必要的初始化操作, 将其他初始化放到第一个中间件内;
	rpcInfo := &RPCInfo{
		RPCMeta: RPCMeta{
			Method: method,
		},
	}

	if tp, ok := ctx.Value(infrastructionKey).(thrift.TProtocol); ok {
		if trans, ok := tp.Transport().(*thrift.HeaderTransport); ok {
			// Send back some headers
			wallClock := time.Now().Round(0).UnixNano() / 1000
			trans.SetHeader("K_ProcessAtTime", strconv.FormatInt(wallClock, 10))
		}
	}

	return newCtxWithRPCInfo(ctx, rpcInfo)
}

// MethodContext called by code generated by kitool to get a inited context
func MethodContext(method string) context.Context {
	var ok bool
	var ctx context.Context

	ptr := uintptr(gls.GetGID())
	if ptr == 0 {
		ctx = context.Background()
	} else {
		glsStorage := gls.FromUnsafePointer(unsafe.Pointer(ptr))
		if ctx, ok = glsStorage.GetData("context").(context.Context); !ok {
			ctx = context.Background()
		}
	}

	return InitMethodContext(ctx, method)
}

// DefineProcessor called by code generated by kitool to set Processer
func DefineProcessor(p thrift.TProcessor) {
	if Processor != nil {
		panic("DefineProcessor more than onece")
	}
	Processor = p
}

// SetIDL called by code generated by kitool to define method
func SetIDL(filename, content string) {
	IDLs[filename] = content
}

// KiteMW wrap every endpoint in this service, called by code generated by kitool
func KiteMW(next endpoint.EndPoint) endpoint.EndPoint {
	chainedMWOnce.Do(func() {
		chainedMW = newChainedMW()
	})
	return chainedMW(next)
}

var chainedMWOnce sync.Once

// chainedMW is the middleware chained collection
var chainedMW endpoint.Middleware

// newChainedMW chains all middleware in the kite
func newChainedMW() endpoint.Middleware {
	var mids, optMids []endpoint.Middleware

	if EnableTracing {
		mids = append(mids, OpenTracingMW)
	}
	if !ServiceMeshMode {
		optMids = []endpoint.Middleware{
			ExposeCtxMW,
			AccessLogMW,
			AccessMetricsMW,
			ACLMW,
			EndpointQPSLimitMW,
			StressBotMW,
			RecoverMW,
			AdditionMW,
			BaseRespCheckMW,
		}
	} else {
		optMids = []endpoint.Middleware{
			ExposeCtxMW,
			MeshReplyHeadersMW,
			AccessLogMW,
			AccessMetricsMW,
			RecoverMW,
			AdditionMW,
			BaseRespCheckMW,
		}
	}
	mids = append(mids, optMids...)
	if !NoPushNotice {
		mids = append(mids, PushNoticeMW)
	}
	mid := endpoint.Chain(ParserMW, mids...)
	return mid
}

var mMap = make(map[string]endpoint.Middleware)
var userMW endpoint.Middleware

// AddMethodMW use a middleware for a define method.
// Note: this function must not be called after kite.Init() is invoked.
func AddMethodMW(m string, mws ...endpoint.Middleware) {
	if len(mws) >= 1 {
		if mw, ok := mMap[m]; ok {
			mMap[m] = endpoint.Chain(mw, mws...)
		} else {
			mMap[m] = endpoint.Chain(mws[0], mws[1:]...)
		}
	}
}

// Use middlewares will enable for all this service's method.
// Note: this function must not be called after kite.Init() is invoked.
func Use(mws ...endpoint.Middleware) {
	if len(mws) >= 1 {
		if userMW != nil {
			userMW = endpoint.Chain(userMW, mws...)
		} else {
			userMW = endpoint.Chain(mws[0], mws[1:]...)
		}
	}
}

// GetLocalIp for compatibility
func GetLocalIp() string {
	return env.HostIP()
}

// NewCallLogger for compatibility
func NewCallLogger(logDir string, serviceName string, useScribe bool) *logs.Logger {
	filename := filepath.Join(logDir, serviceName+".call.log")
	return newRPCLogger(filename)
}

// NewAccessLogger for compatibility
func NewAccessLogger(logDir string, serviceName string, useScribe bool) *logs.Logger {
	filename := filepath.Join(logDir, serviceName+".access.log")
	return newRPCLogger(filename)
}

// TODO: eliminate all global variables
var kiteMetricsControl kiterrno.MetricsControl = CompatibleMetrics

// WithMetricsControl provides a way to control the decision of whether certain response
// should be treated as error, and what tags should be output in metrics.
func WithMetricsControl(mc kiterrno.MetricsControl) {
	if mc == nil {
		panic("Nil is no longer supportted. Use kite.UncompatibleMetrics instead.")
	} else {
		kiteMetricsControl = mc
	}
}

func WithGLSEnable() {
	enableGLS = true
}

func WithRunEnvKey(env string) {
	runEnvKey = env
}
